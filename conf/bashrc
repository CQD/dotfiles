# If not running interactively, don't do anything
[ -z "$PS1" ] && return

###############################
# Basics
###############################

export EDITOR=vim
export CLICOLOR=1
export LSCOLORS=ExFxCxDxBxegedabagacad
export TERM=xterm-256color

[ -n "$TMUX" ] && export TERM=screen-256color # tmux matches screen instead of xterm
                                              # https://superuser.com/questions/424086
PATH=$PATH:~/bin

PS_TRIANGLE=$'\uE0B0'

export VIRTUAL_ENV_DISABLE_PROMPT=1  # 停用 virtualenv 的 prompt 改寫，後面會用 $VIRTUAL_ENV 來判斷

###############################
# Prompt styling
###############################

# print git branch status
function git_branch {
    # modified files
    st=$(git status -s 2> /dev/null )
    if [ ! $? == "0" ] ; then
        return
    fi

    flags_s=""
    flags_ns=""

    if [ ! "" == "$st" ] ; then
        while IFS= read -r line; do
            staged_flag="${line:0:1}"
            not_staged_flag="${line:1:1}"

            if [ ! "$staged_flag" == " " ] && [ ! "$staged_flag" == "?" ]; then
                flags_s+=$staged_flag
            fi

            if [[ "$not_staged_flag" != " " ]]; then
                flags_ns+=$not_staged_flag
            fi
        done <<< "$st"
    fi

    # ref name, or commit hash
    head_type='b' # branch
    ref=$(git symbolic-ref --short HEAD 2> /dev/null);

    if [ "" == "$ref" ] ; then
        head_type='h' # hash
        ref=$( git rev-parse --short HEAD 2> /dev/null );
    fi

    # print result
    echo "$head_type $ref _$flags_s _$flags_ns";
}

# random choose color according to input string
# ref: https://stackoverflow.com/a/27165165
function rand_color {
    min=$1
    scale=$2
    text=$3

    r=-1; g=-1; b=-1

    RANDOM=$(num-from-string $text); #seed with input string
    r=$(( ( $RANDOM % $scale ) + $min));
    g=$(( ( $RANDOM % $scale ) + $min));
    b=$(( ( $RANDOM % $scale ) + $min));

    color_code=$(( 16 + 36 * $r + 6 * $g + $b))
    color_code=$(printf "%03d" $color_code)
    echo $color_code
}

function num-from-string {
    local out i a

    out=1
    for ((i=0;i<${#1};++i)); do
        printf -v a "%d\n" "'${1:i:1}"
        out+=$((a%10))
    done
    echo $(($out % 1000000))
}

function ps_login {
    _HOSTNAME=${PS_HOSTNAME:-$HOSTNAME}
    _HOSTNAME=${_HOSTNAME/.lan/}
    _HOSTNAME=${_HOSTNAME/.compute.internal/.aws}

    user_color=$(rand_color 3 3 $USER)
    host_color=$(rand_color 3 3 $_HOSTNAME)

    bgcolor=017

    if [ "$USER" == "root" ]; then
        user_color="196"
    fi

    echo -ne '\[\e[48;5;'$bgcolor'm\e[38;5;'$user_color'm\] '$USER'\[\e[38;5;248m\]@\[\e[38;5;'$host_color'm\]'$_HOSTNAME' \[\e[38;5;'$bgcolor'm\]'
}

function ps_path {
    bgcolor=026
    fgcolor=255
    local_path=${PWD/#$HOME/\~}

    echo -ne '\[\e[48;5;'$bgcolor'm\]'$PS_TRIANGLE'\[\e[38;5;'$fgcolor'm\] '$local_path' \[\e[38;5;'$bgcolor'm\]'
}

function ps_git {
    local branch prefix color

    git_info=$(git_branch)
    if [ "$git_info" == "" ] ; then
        return
    fi

    git_info=( $git_info )
    prefix=${git_info[0]}
    branch=${git_info[1]}
    flag_staged=${git_info[2]/_/}
    flag_not_staged=${git_info[3]/_/}

    branch_symbol='⎇'

    fgcolor=231

    if [ "$prefix" == "b" ] ; then
        if [ "$branch" == "master" ] || [ "$branch" == "main" ] ; then
            bgcolor=028
        elif [ "$branch" == "develop" ] ; then
            bgcolor=100
        else
            bgcolor=$(rand_color 0 3 $branch)
        fi
    else
        bgcolor=136
        branch_symbol='➦'
    fi

    echo -ne '\[\e[48;5;'$bgcolor'm\]'$PS_TRIANGLE'\[\e[38;5;'$fgcolor'm\] '$branch_symbol' '$branch' '

    echo -ne '\[\e[m\]'

    if [ ! "" == "$flag_staged" ] ; then
      bgcolor=003
      echo -ne '\[\e[0;43;30m\]' $flag_staged' '
    fi
    if [ ! "" == "$flag_not_staged" ] ; then
      bgcolor=001
      echo -ne '\[\e[1;41;37m\]' $flag_not_staged' '
    fi

    echo -e '\[\e[0;38;5;'$bgcolor'm\]'
}

function ps_time {
    fgcolor=253
    bgcolor=237
    time_str=$(date '+%H:%M:%S')
    echo -ne '\[\e[48;5;'$bgcolor'm\e[38;5;'$fgcolor'm\] '$time_str' \[\e[38;5;'$bgcolor'm\]'
}

function ps_venv() {
    if [ "" == "$VIRTUAL_ENV" ] ; then
        return
    fi

    # replace '/venv' with ''
    parent_name=${VIRTUAL_ENV/\/venv/}
    venv_name=$(basename $parent_name)

    fgcolor=226
    bgcolor=094

    echo -ne "\[\e[48;5;${bgcolor}m\]${PS_TRIANGLE}\[\e[38;5;${fgcolor}m\] 🐍$venv_name \[\e[38;5;${bgcolor}m\]"
}

function ps_marker() {
    _STATUS=$1

    _PS_STATUS=''

    fgcolor=000
    bgcolor=255

    if [ $_STATUS -ne 0 ] ; then
        fgcolor=255
        bgcolor=196
        _PS_STATUS=' '$_STATUS' '
    fi

    echo -ne '\[\e[48;5;'$bgcolor'm\]'$PS_TRIANGLE'\[\e[38;5;'$fgcolor'm\] '$_PS_STATUS'$ \[\e[38;5;'$bgcolor'm\]'
}
function ps_run() {
    prev_status_code=$?  # store status for later use, as it will be cleared by next command

    _LINE_END='\[\e[40m\]'$PS_TRIANGLE'\[\e[0;30m\]'

    # start_time=$EPOCHREALTIME
    echo -ne "\n"$(ps_login)$(ps_path)$(ps_git)"$_LINE_END\n"
    echo -ne $(ps_time)$(ps_venv)$(ps_marker "$prev_status_code")
    echo -ne "$_LINE_END \[\e[0m\]"
    # end_time=$EPOCHREALTIME
    # echo -ne $(scale=3 echo "$end_time - $start_time" | bc)" "
}

PROMPT_COMMAND='PS1=$(ps_run)'

###############################
# Run scripts
###############################

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

# include machine depending settings that not to be included in dotfile repo
if [ -f ~/.bashrc_local ] ; then
    source ~/.bashrc_local
fi

# ssh-agent manangement
if [ "" == "$SSH_AUTH_SOCK" ]; then
    if ! type -p ssh-agent; then
        echo "Can not init ssh-agent, command not available!"
    else
        echo "Initing ssh-agent"
        eval $(ssh-agent)
    fi
fi

###############################
# alias
###############################

#sets up proper alias commands when called
if [ "$(uname)" = "Linux" ]; then
    # set up color for linux
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
    alias ls='ls --color=auto -vG'
elif [ "$(uname)" = "Darwin" ]; then
    alias ls='ls -vG'
else
    alias ls='ls -G'
fi

alias ll='ls -l'
alias la='ls -a'
alias lla='ls -al'

# tmux alias
alias ta='tmux attach'

# Docker alias
dp() {
    nice -n 19 docker compose $@
}

dps() {
    dp exec "$1" /bin/bash || dp exec "$1" /bin/sh
}

dpe() {
    dp exec $@
}

# python alias

_resolve_python() {
    if type python3 &> /dev/null ; then
        echo python3
    else
        echo python
    fi
}

venv() {
    py=$(_resolve_python)
    $py -m venv $@
}

av() {
    if [ "" != "$VIRTUAL_ENV" ] ; then
        echo "已啟動 virtual env"
        return
    fi
    current_folder=${PWD##*/}
    current_folder=${current_folder:-root}

    base=${1:-venv}
    name=${2:-$current_folder}

    if [ "" == "$1" ] && [ ! -d "$base" ] && [ -d ".venv" ] ; then
        base=".venv"
    fi

    if [ ! -f $base/bin/activate ]; then
        py=$(_resolve_python)
        echo "把 virtual env 建立到 $base"
        type $py
        echo "python 版本: "$($py --version)
        venv --prompt $name $base
    fi
    . $base/bin/activate
}

dv() {
    if [ "" == "$VIRTUAL_ENV" ] ; then
        echo "沒有啟動中的 virtual env"
        return
    fi
    deactivate
}

# Hack for tmux agent forwarding
fixssh() {
    eval $(tmux show-env -s |grep '^SSH_')
    echo SSH_* envs re-evaluated.
}
if  [ "$TMUX" ]; then
    fixssh
fi

# misc
man () {
    case "$(type -t -- "$1")" in
    builtin|keyword)
        help "$1"
        ;;
    *)
        command man "$@"
        ;;
    esac
}

cdp() {
    TTT=$(pwd)
    while ! [ -d .git ]; do
        cd ..
    done
    if ! [ "" == "$1" ]; then
        cd $1
    fi
    OLDPWD=$TTT
}
